library(ggmap)
ggmap(location)
}
?ggmap
makeMap(location="Philadelphia", zlevel=8)
makeMap <- function(location='New York',
zlevel=8,
mtype='hybrid') {
library(ggmap)
ggmap(get_map(location))
}
makeMap(location="Philadelphia", zlevel=8)
makeMap <- function(location='New York',
zlevel=8,
mtype='hybrid') {
library(ggmap)
ggmap(get_map(location)) + xlab("latitude")
}
makeMap(location="Philadelphia", zlevel=8)
makeMap <- function(location='New York',
zlevel=8,
mtype='hybrid') {
library(ggmap)
ggmap(get_map(location, zlevel)) +
ylab('latitude') +
xlab('longitude')
}
makeMap(location="Philadelphia", zlevel=8)
makeMap <- function(location='New York',
zlevel=8,
mtype='road') {
library(ggmap)
ggmap(get_map(location, zlevel)) +
ylab('latitude') +
xlab('longitude')
}
makeMap(location="Philadelphia", zlevel=8, mtype='hybrid')
makeMap <- function(location='New York',
zlevel=8,
mtype='road') {
library(ggmap)
ggmap(get_map(location, zlevel, mtype)) +
ylab('latitude') +
xlab('longitude')
}
makeMap(location="Philadelphia", zlevel=8, mtype='hybrid')
makeMap <- function(location='New York',
zlevel=8,
mtype='road') {
library(ggmap)
ggmap(get_map(location, zlevel, maptype=mtype)) +
ylab('latitude') +
xlab('longitude')
}
makeMap(location="Philadelphia", zlevel=8, mtype='hybrid')
makeMap(location="Philadelphia", zlevel=8, mtype='road')
makeMap(location="Toms River", zlevel=8, mtype='road')
makeMap(location="Toms River", zlevel=7, mtype='road')
version
a <- 6371.2             # reference radius of Earth
# following radii (A & B) are used for transforming between geodetic and geocentric coordinates
A <- 40680631.59 ^ 0.5  # semi-major axe of reference spheroid (equatorial radius of Earth, WGS84)
B <- 40408299.89 ^ 0.5  # semi-minor axe of reference spheroid (polar radius of Earth, WGS84)
main <- function(h, lat, lon, days) {
# convert lat/lon from degrees to radians
lambda <- lon * pi / 180
phi <- lat * pi / 180
# convert geographic coords to spherical coords
# flattening
f <- (h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + A^2)^2 /
(h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + B^2)^2
# geocentric latitude
theta <- acos(sin(phi) /
(f * (cos(phi))^2 + (sin(phi))^2)^0.5)
# geocentric radius
r <- ((h^2 + 2 * h * (A^2 - (A^2 - B^2) * (sin(phi))^2)^0.5 +
(A^4 - (A^4 - B^4) * (sin(phi))^2)) /
(A^2 - (A^2 - B^2) * (sin(phi))^2))^0.5
delta <- phi + theta - pi / 2
# avoid singularities at the poles
if (theta > -0.00000001 & theta < 0.00000001) theta <- 0.00000001
if (theta < pi & theta > (pi - 0.00000001)) theta <- pi - 0.00000001
# compute Schmidt Quasi-Normalized Gaussian coefficients
tidyData <- ghSchmidtQuasiNorm()
# calculate g and h values at specified time
tidyData$gt <- tidyData$gS + days/365 * tidyData$gSsv
tidyData$ht <- tidyData$hS + days/365 * tidyData$hSsv
# compute the Gaussian normalized associated Legendre polynomials & derivatives of associated Legendre polynomials
tidyData$P <- apply(tidyData[,c('n','m')], 1, function(x) Pnm(x['n'], x['m'], theta))
tidyData$dP <- apply(tidyData[,c('n','m')], 1, function(x) dPnm(x['n'], x['m'], theta))
print(igrf(tidyData, r, theta, lambda, delta))
}
# calculate the derivatives of the scalar potential function
igrf <- function(data, r, theta, lambda, delta) {
# radial component
data$Br <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$P
Br <- data.frame(matrix(unlist(aggregate(data$Br, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Br$BrC <- ((a / r)^(Br[,1] + 2)) * (Br[,1] + 1) * Br[,2]
Br <- sum(Br$BrC)
# theta component
data$Bt <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$dP
Bt <- data.frame(matrix(unlist(aggregate(data$Bt, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bt$BtC <- ((a / r)^(Bt[,1] + 2)) * Bt[,2]
Bt <- -1 * sum(Bt$BtC)
# lambda component
data$Bl <- data$m * (-1 * data$gt * sin(data$m * lambda) + data$ht * cos(data$m * lambda)) * data$P
Bl <- data.frame(matrix(unlist(aggregate(data$Bl, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bl$BlC <- ((a / r)^(Bl[,1] + 2)) * Bl[,2]
Bl <- (-1/sin(theta))*sum(Bl$BlC)
# convert to local tangential coordinates
Bxc <- -Bt   # north-south
Byc <- Bl    # east-west
Bzc <- -Br   # vertical
# convert to local cartesian coordinates
Bx <- Bxc * cos(delta) + Bzc * sin(delta)
By <- Byc
Bz <- -1 * Bxc * sin(delta) + Bzc * cos(delta)
# return data frame containing dec, inc, Bh, Bx, By, Bz, and TF
data.frame(dec=atan(By/Bx)*180/pi,
inc=atan(Bz/(Bx^2+By^2)^0.5),
Bh=(Bx^2+By^2)^0.5,
Bx=Bx,
By=By,
Bz=Bz,
TF=(Bx^2+By^2+Bz^2)^0.5)
}
ghSchmidtQuasiNorm <- function(year="2015") {
library(dplyr)
# download and load data
data <- downloadData()
# reshape and filter data
igrf <- cleanData(data, paste0("IGRF", year))
sv <- cleanData(data, "SV")
tidyData <- inner_join(igrf, sv, by="id")
names(tidyData) <- c("n", "m", "g", "h", "id", "n.y", "m.y", "gsv", "hsv")
tidyData <- tidyData %>% select(-id, -n.y, -m.y)
tidyData$h[is.na(tidyData$h)] <- 0
tidyData$hsv[is.na(tidyData$hsv)] <- 0
# compute Schmidt quasi-normalization factors
tidyData$Snm <- apply(tidyData[,c('n','m')], 1, function(x) Snm(x['n'], x['m']))
# normalize g, h, gsv, and hsv using Schmidt quasi-normalization coefficients from above
tidyData$gS <- tidyData$Snm * tidyData$g
tidyData$hS <- tidyData$Snm * tidyData$h
tidyData$gSsv <- tidyData$Snm * tidyData$gsv
tidyData$hSsv <- tidyData$Snm * tidyData$hsv
# return tidyData dataframe
tidyData
}
# recursively calculate derivatives of associated Legendre Polynomials
dPnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute dPnm
if (n == 0 && m == 0) dP <- 0
else if (n == m) dP <- sin(theta) * dPnm(n-1,m-1,theta) + cos(theta) * Pnm(n-1, m-1,theta)
else dP <- ifelse(K == 0, cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta),
cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta) - K * dPnm(n-2, m, theta))
dP
}
# recursively calculate Associated Legendre Polynomials
Pnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute Pnm
if (n == 0 && m == 0) P <- 1
else if (n == m) P <- sin(theta) * Pnm(n-1, m-1, theta)
else P <- ifelse(K == 0, cos(theta) * Pnm(n-1, m, theta), cos(theta) * Pnm(n-1, m, theta) - K * Pnm(n-2, m, theta))
P
}
Snm <- function(n, m) {
# Kronecker delta is defined as dij = 1 if i = j, and dij = 0 otherwise
#   our formula for the Schmidt quasi-normalization factors in recursive form
#   uses dm1 - so if m = 1, dm1 = 1 otherwise dm1 = 0
kdelta <- ifelse(m==1, 1, 0)
if (n == 0 && m == 0) S <- 1
else if (m == 0) S <- Snm(n-1,0) * (2 * n - 1) / n
else S <- Snm(n, m-1) * (((n - m + 1)*(kdelta + 1))/(n + m))^0.5
}
# filter and clean data
cleanData <- function(data, filter_field) {
library(reshape2)
library(tidyr)
# reshape and filter data
temp <- data %>%
melt(id=c("gh", "n", "m"), value.name="coeff") %>%
spread(gh, coeff) %>%
filter(variable == filter_field) %>%
select(-variable) %>%
mutate(id = paste0(n,m))
}
# download IGRF 12 coefficients - if not already present
downloadData <- function(file="igrf12coeffs.txt") {
# load data
igrf <- read.table(paste0("./data/", file), header=FALSE, skip=4,
col.names = c("gh", "n", "m", "IGRF1900", "IGRF1905", "IGRF1910", "IGRF1915", "IGRF1920",
"IGRF1925", "IGRF1930", "IGRF1935", "IGRF1940", "DGRF1945", "DGRF1950",
"DGRF1955", "DGRF1960", "DGRF1965", "DGRF1970", "DGRF1975", "DGRF1980",
"DGRF1985", "DGRF1990", "DGRF1995", "DGRF2000", "DGRF2005", "DGRF2010",
"IGRF2015", "SV"),
colClasses = c("character", rep("numeric", 27)))
}
main(0, 30, 30, 1)
install.packages("dplyr")
main(0, 30, 30, 1)
install.packages("tidyr")
main(0, 30, 30, 1)
sys.Date()
sys.date()
Sys.date()
Sys.Date
Sys.Date()
today <- Sys.Date()
a <- 6371.2             # reference radius of Earth
# following radii (A & B) are used for transforming between geodetic and geocentric coordinates
A <- 40680631.59 ^ 0.5  # semi-major axe of reference spheroid (equatorial radius of Earth, WGS84)
B <- 40408299.89 ^ 0.5  # semi-minor axe of reference spheroid (polar radius of Earth, WGS84)
main <- function(h, lat, lon, date) {
# convert lat/lon from degrees to radians
lambda <- lon * pi / 180
phi <- lat * pi / 180
# convert geographic coords to spherical coords
# flattening
f <- (h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + A^2)^2 /
(h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + B^2)^2
# geocentric latitude
theta <- acos(sin(phi) /
(f * (cos(phi))^2 + (sin(phi))^2)^0.5)
# geocentric radius
r <- ((h^2 + 2 * h * (A^2 - (A^2 - B^2) * (sin(phi))^2)^0.5 +
(A^4 - (A^4 - B^4) * (sin(phi))^2)) /
(A^2 - (A^2 - B^2) * (sin(phi))^2))^0.5
delta <- phi + theta - pi / 2
# avoid singularities at the poles
if (theta > -0.00000001 & theta < 0.00000001) theta <- 0.00000001
if (theta < pi & theta > (pi - 0.00000001)) theta <- pi - 0.00000001
# compute Schmidt Quasi-Normalized Gaussian coefficients
tidyData <- ghSchmidtQuasiNorm(format(date, "%Y"))
# calculate g and h values at specified time
tidyData$gt <- tidyData$gS + days/365 * tidyData$gSsv
tidyData$ht <- tidyData$hS + days/365 * tidyData$hSsv
# compute the Gaussian normalized associated Legendre polynomials & derivatives of associated Legendre polynomials
tidyData$P <- apply(tidyData[,c('n','m')], 1, function(x) Pnm(x['n'], x['m'], theta))
tidyData$dP <- apply(tidyData[,c('n','m')], 1, function(x) dPnm(x['n'], x['m'], theta))
print(igrf(tidyData, r, theta, lambda, delta))
}
# calculate the derivatives of the scalar potential function
igrf <- function(data, r, theta, lambda, delta) {
# radial component
data$Br <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$P
Br <- data.frame(matrix(unlist(aggregate(data$Br, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Br$BrC <- ((a / r)^(Br[,1] + 2)) * (Br[,1] + 1) * Br[,2]
Br <- sum(Br$BrC)
# theta component
data$Bt <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$dP
Bt <- data.frame(matrix(unlist(aggregate(data$Bt, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bt$BtC <- ((a / r)^(Bt[,1] + 2)) * Bt[,2]
Bt <- -1 * sum(Bt$BtC)
# lambda component
data$Bl <- data$m * (-1 * data$gt * sin(data$m * lambda) + data$ht * cos(data$m * lambda)) * data$P
Bl <- data.frame(matrix(unlist(aggregate(data$Bl, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bl$BlC <- ((a / r)^(Bl[,1] + 2)) * Bl[,2]
Bl <- (-1/sin(theta))*sum(Bl$BlC)
# convert to local tangential coordinates
Bxc <- -Bt   # north-south
Byc <- Bl    # east-west
Bzc <- -Br   # vertical
# convert to local cartesian coordinates
Bx <- Bxc * cos(delta) + Bzc * sin(delta)
By <- Byc
Bz <- -1 * Bxc * sin(delta) + Bzc * cos(delta)
# return data frame containing dec, inc, Bh, Bx, By, Bz, and TF
data.frame(dec=atan(By/Bx)*180/pi,
inc=atan(Bz/(Bx^2+By^2)^0.5),
Bh=(Bx^2+By^2)^0.5,
Bx=Bx,
By=By,
Bz=Bz,
TF=(Bx^2+By^2+Bz^2)^0.5)
}
ghSchmidtQuasiNorm <- function(year="2015") {
library(dplyr)
print(year)
# download and load data
data <- downloadData()
# reshape and filter data
igrf <- cleanData(data, paste0("IGRF", year))
sv <- cleanData(data, "SV")
tidyData <- inner_join(igrf, sv, by="id")
names(tidyData) <- c("n", "m", "g", "h", "id", "n.y", "m.y", "gsv", "hsv")
tidyData <- tidyData %>% select(-id, -n.y, -m.y)
tidyData$h[is.na(tidyData$h)] <- 0
tidyData$hsv[is.na(tidyData$hsv)] <- 0
# compute Schmidt quasi-normalization factors
tidyData$Snm <- apply(tidyData[,c('n','m')], 1, function(x) Snm(x['n'], x['m']))
# normalize g, h, gsv, and hsv using Schmidt quasi-normalization coefficients from above
tidyData$gS <- tidyData$Snm * tidyData$g
tidyData$hS <- tidyData$Snm * tidyData$h
tidyData$gSsv <- tidyData$Snm * tidyData$gsv
tidyData$hSsv <- tidyData$Snm * tidyData$hsv
# return tidyData dataframe
tidyData
}
# recursively calculate derivatives of associated Legendre Polynomials
dPnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute dPnm
if (n == 0 && m == 0) dP <- 0
else if (n == m) dP <- sin(theta) * dPnm(n-1,m-1,theta) + cos(theta) * Pnm(n-1, m-1,theta)
else dP <- ifelse(K == 0, cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta),
cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta) - K * dPnm(n-2, m, theta))
dP
}
# recursively calculate Associated Legendre Polynomials
Pnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute Pnm
if (n == 0 && m == 0) P <- 1
else if (n == m) P <- sin(theta) * Pnm(n-1, m-1, theta)
else P <- ifelse(K == 0, cos(theta) * Pnm(n-1, m, theta), cos(theta) * Pnm(n-1, m, theta) - K * Pnm(n-2, m, theta))
P
}
Snm <- function(n, m) {
# Kronecker delta is defined as dij = 1 if i = j, and dij = 0 otherwise
#   our formula for the Schmidt quasi-normalization factors in recursive form
#   uses dm1 - so if m = 1, dm1 = 1 otherwise dm1 = 0
kdelta <- ifelse(m==1, 1, 0)
if (n == 0 && m == 0) S <- 1
else if (m == 0) S <- Snm(n-1,0) * (2 * n - 1) / n
else S <- Snm(n, m-1) * (((n - m + 1)*(kdelta + 1))/(n + m))^0.5
}
# filter and clean data
cleanData <- function(data, filter_field) {
library(reshape2)
library(tidyr)
# reshape and filter data
temp <- data %>%
melt(id=c("gh", "n", "m"), value.name="coeff") %>%
spread(gh, coeff) %>%
filter(variable == filter_field) %>%
select(-variable) %>%
mutate(id = paste0(n,m))
}
# download IGRF 12 coefficients - if not already present
downloadData <- function(file="igrf12coeffs.txt") {
# load data
igrf <- read.table(paste0("./data/", file), header=FALSE, skip=4,
col.names = c("gh", "n", "m", "IGRF1900", "IGRF1905", "IGRF1910", "IGRF1915", "IGRF1920",
"IGRF1925", "IGRF1930", "IGRF1935", "IGRF1940", "DGRF1945", "DGRF1950",
"DGRF1955", "DGRF1960", "DGRF1965", "DGRF1970", "DGRF1975", "DGRF1980",
"DGRF1985", "DGRF1990", "DGRF1995", "DGRF2000", "DGRF2005", "DGRF2010",
"IGRF2015", "SV"),
colClasses = c("character", rep("numeric", 27)))
}
main(0, 30, 30, 1)
format(today, "%Y")
a <- 6371.2             # reference radius of Earth
# following radii (A & B) are used for transforming between geodetic and geocentric coordinates
A <- 40680631.59 ^ 0.5  # semi-major axe of reference spheroid (equatorial radius of Earth, WGS84)
B <- 40408299.89 ^ 0.5  # semi-minor axe of reference spheroid (polar radius of Earth, WGS84)
main <- function(h, lat, lon, date) {
# convert lat/lon from degrees to radians
lambda <- lon * pi / 180
phi <- lat * pi / 180
# convert geographic coords to spherical coords
# flattening
f <- (h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + A^2)^2 /
(h * (A^2 - (A^2 - B^2) * (sin(lat))^2)^0.5 + B^2)^2
# geocentric latitude
theta <- acos(sin(phi) /
(f * (cos(phi))^2 + (sin(phi))^2)^0.5)
# geocentric radius
r <- ((h^2 + 2 * h * (A^2 - (A^2 - B^2) * (sin(phi))^2)^0.5 +
(A^4 - (A^4 - B^4) * (sin(phi))^2)) /
(A^2 - (A^2 - B^2) * (sin(phi))^2))^0.5
delta <- phi + theta - pi / 2
# avoid singularities at the poles
if (theta > -0.00000001 & theta < 0.00000001) theta <- 0.00000001
if (theta < pi & theta > (pi - 0.00000001)) theta <- pi - 0.00000001
# compute Schmidt Quasi-Normalized Gaussian coefficients
tidyData <- ghSchmidtQuasiNorm(as.numeric(format(date, "%Y")))
# calculate g and h values at specified time
tidyData$gt <- tidyData$gS + days/365 * tidyData$gSsv
tidyData$ht <- tidyData$hS + days/365 * tidyData$hSsv
# compute the Gaussian normalized associated Legendre polynomials & derivatives of associated Legendre polynomials
tidyData$P <- apply(tidyData[,c('n','m')], 1, function(x) Pnm(x['n'], x['m'], theta))
tidyData$dP <- apply(tidyData[,c('n','m')], 1, function(x) dPnm(x['n'], x['m'], theta))
print(igrf(tidyData, r, theta, lambda, delta))
}
# calculate the derivatives of the scalar potential function
igrf <- function(data, r, theta, lambda, delta) {
# radial component
data$Br <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$P
Br <- data.frame(matrix(unlist(aggregate(data$Br, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Br$BrC <- ((a / r)^(Br[,1] + 2)) * (Br[,1] + 1) * Br[,2]
Br <- sum(Br$BrC)
# theta component
data$Bt <- (data$gt * cos(data$m * lambda) + data$ht * sin(data$m * lambda)) * data$dP
Bt <- data.frame(matrix(unlist(aggregate(data$Bt, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bt$BtC <- ((a / r)^(Bt[,1] + 2)) * Bt[,2]
Bt <- -1 * sum(Bt$BtC)
# lambda component
data$Bl <- data$m * (-1 * data$gt * sin(data$m * lambda) + data$ht * cos(data$m * lambda)) * data$P
Bl <- data.frame(matrix(unlist(aggregate(data$Bl, by=list(n=data$n), FUN=sum)), ncol=2, byrow=F))
Bl$BlC <- ((a / r)^(Bl[,1] + 2)) * Bl[,2]
Bl <- (-1/sin(theta))*sum(Bl$BlC)
# convert to local tangential coordinates
Bxc <- -Bt   # north-south
Byc <- Bl    # east-west
Bzc <- -Br   # vertical
# convert to local cartesian coordinates
Bx <- Bxc * cos(delta) + Bzc * sin(delta)
By <- Byc
Bz <- -1 * Bxc * sin(delta) + Bzc * cos(delta)
# return data frame containing dec, inc, Bh, Bx, By, Bz, and TF
data.frame(dec=atan(By/Bx)*180/pi,
inc=atan(Bz/(Bx^2+By^2)^0.5),
Bh=(Bx^2+By^2)^0.5,
Bx=Bx,
By=By,
Bz=Bz,
TF=(Bx^2+By^2+Bz^2)^0.5)
}
ghSchmidtQuasiNorm <- function(year="2015") {
library(dplyr)
print(year)
# download and load data
data <- downloadData()
# reshape and filter data
igrf <- cleanData(data, paste0("IGRF", year))
sv <- cleanData(data, "SV")
tidyData <- inner_join(igrf, sv, by="id")
names(tidyData) <- c("n", "m", "g", "h", "id", "n.y", "m.y", "gsv", "hsv")
tidyData <- tidyData %>% select(-id, -n.y, -m.y)
tidyData$h[is.na(tidyData$h)] <- 0
tidyData$hsv[is.na(tidyData$hsv)] <- 0
# compute Schmidt quasi-normalization factors
tidyData$Snm <- apply(tidyData[,c('n','m')], 1, function(x) Snm(x['n'], x['m']))
# normalize g, h, gsv, and hsv using Schmidt quasi-normalization coefficients from above
tidyData$gS <- tidyData$Snm * tidyData$g
tidyData$hS <- tidyData$Snm * tidyData$h
tidyData$gSsv <- tidyData$Snm * tidyData$gsv
tidyData$hSsv <- tidyData$Snm * tidyData$hsv
# return tidyData dataframe
tidyData
}
# recursively calculate derivatives of associated Legendre Polynomials
dPnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute dPnm
if (n == 0 && m == 0) dP <- 0
else if (n == m) dP <- sin(theta) * dPnm(n-1,m-1,theta) + cos(theta) * Pnm(n-1, m-1,theta)
else dP <- ifelse(K == 0, cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta),
cos(theta) * dPnm(n-1, m, theta) - sin(theta) * Pnm(n-1, m, theta) - K * dPnm(n-2, m, theta))
dP
}
# recursively calculate Associated Legendre Polynomials
Pnm <- function(n, m, theta) {
# calculate K
K <- ((n-1)^2-m^2) / ((2*n-1)*(2*n-3))
# compute Pnm
if (n == 0 && m == 0) P <- 1
else if (n == m) P <- sin(theta) * Pnm(n-1, m-1, theta)
else P <- ifelse(K == 0, cos(theta) * Pnm(n-1, m, theta), cos(theta) * Pnm(n-1, m, theta) - K * Pnm(n-2, m, theta))
P
}
Snm <- function(n, m) {
# Kronecker delta is defined as dij = 1 if i = j, and dij = 0 otherwise
#   our formula for the Schmidt quasi-normalization factors in recursive form
#   uses dm1 - so if m = 1, dm1 = 1 otherwise dm1 = 0
kdelta <- ifelse(m==1, 1, 0)
if (n == 0 && m == 0) S <- 1
else if (m == 0) S <- Snm(n-1,0) * (2 * n - 1) / n
else S <- Snm(n, m-1) * (((n - m + 1)*(kdelta + 1))/(n + m))^0.5
}
# filter and clean data
cleanData <- function(data, filter_field) {
library(reshape2)
library(tidyr)
# reshape and filter data
temp <- data %>%
melt(id=c("gh", "n", "m"), value.name="coeff") %>%
spread(gh, coeff) %>%
filter(variable == filter_field) %>%
select(-variable) %>%
mutate(id = paste0(n,m))
}
# download IGRF 12 coefficients - if not already present
downloadData <- function(file="igrf12coeffs.txt") {
# load data
igrf <- read.table(paste0("./data/", file), header=FALSE, skip=4,
col.names = c("gh", "n", "m", "IGRF1900", "IGRF1905", "IGRF1910", "IGRF1915", "IGRF1920",
"IGRF1925", "IGRF1930", "IGRF1935", "IGRF1940", "DGRF1945", "DGRF1950",
"DGRF1955", "DGRF1960", "DGRF1965", "DGRF1970", "DGRF1975", "DGRF1980",
"DGRF1985", "DGRF1990", "DGRF1995", "DGRF2000", "DGRF2005", "DGRF2010",
"IGRF2015", "SV"),
colClasses = c("character", rep("numeric", 27)))
}
format(today, "%Y")
main(0, 30, 30, 1)
format(today, "%Y")
as.numeric(format(today, "%Y"))
main(0, 30, 30, today)
library(shiny)
runApp()
setwd("C:/Projects/igrf_app")
runApp()
runApp()
runApp()
runApp()
